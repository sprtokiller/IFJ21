D:Token at [3, 1]: u_minus
D:Token at [4, 1]: u_plus
D:Token at [5, 1]: string literal
D: Val: "string"
D:Token at [6, 1]: less then comparison
D: Val: <
D:Token at [7, 1]: greater then comparison
D: Val: >
D:Token at [8, 1]: multiply
D:Token at [9, 1]: divide
D: Val: /
D:Token at [10, 1]: integer divide
D: Val: //
D:Token at [11, 1]: not equality
D:Token at [12, 1]: length
D:Token at [13, 1]: concatenate
D: Val: ..
D:Token at [14, 1]: less then comparison
D: Val: <
D:Token at [15, 1]: less or equal then comparison
D: Val: <=
D:Token at [16, 1]: greater then comparison
D: Val: >
D:Token at [17, 1]: greater or equal then comparison
D: Val: >=
D:Token at [18, 1]: equality
D: Val: ==
D:Token at [19, 1]: not equality
D:Token at [19, 2]: assignment
D: Val: =
D:Token at [21, 1]: string literal
D: Val: "Ahoj\n\"Sve'te \\\034"
D:Token at [23, 1]: function
D:Token at [23, 10]: identifier
D: Val: reads
D:Token at [23, 15]: left parenthese
D:Token at [23, 16]: right parenthese
D:Token at [23, 18]: colon
D:Token at [23, 20]: string
D:Token at [24, 1]: function
D:Token at [24, 10]: identifier
D: Val: readi
D:Token at [24, 15]: left parenthese
D:Token at [24, 16]: right parenthese
D:Token at [24, 18]: colon
D:Token at [24, 20]: integer
D:Token at [25, 1]: function
D:Token at [25, 10]: identifier
D: Val: readn
D:Token at [25, 15]: left parenthese
D:Token at [25, 16]: right parenthese
D:Token at [25, 18]: colon
D:Token at [25, 20]: number
D:Token at [27, 1]: function
D:Token at [27, 10]: identifier
D: Val: main
D:Token at [27, 14]: left parenthese
D:Token at [27, 15]: right parenthese
D:Token at [36, 1]: identifier
D: Val: id_a
D:Token at [37, 1]: double literal
D: Val: 12.120000000
D:Token at [39, 1]: logical and
D:Token at [40, 1]: boolean
D:Token at [41, 1]: do
D:Token at [42, 1]: end
D:Token at [43, 1]: else
D:Token at [44, 1]: elseif
D:Token at [45, 1]: false
D:Token at [46, 1]: function
D:Token at [47, 1]: integer
D:Token at [48, 1]: if
D:Token at [49, 1]: nil
D:Token at [50, 1]: logical not
D:Token at [51, 1]: number
D:Token at [52, 1]: logical or
D:Token at [53, 1]: string
D:Token at [54, 1]: require
D:Token at [55, 1]: return
D:Token at [56, 1]: then
D:Token at [57, 1]: true
D:Token at [58, 1]: while
D:Token at [59, 0]: eof
